---
title: "Thesis"
subtitle: 'Methods Comparison: Misspecified models & Double Robust Estimator'
author: "Vasiliki Gkika"
date: "`r format(Sys.Date(), '%d-%m-%Y')`"
output: pdf_document
---

```{r include=FALSE}
options(scipen = 999)
options(error = NULL)
```

```{r}
library(survival)
library(ipw)
library(dplyr) |> suppressPackageStartupMessages()
library(matrixStats) |> suppressPackageStartupMessages()

set.seed(2024)
```

# Set parameters for all MC simulations

```{r}
M = 200 # MC simulations
#n = 800 # sample size for each MC iteration
N = 10^6 # sample size for big dataset 

# time grid for all survival estimates
tt = seq(0, 200, by = 0.1)
nt = length(tt)
```

# Set parameters for all model scenarios

```{r}
# baseline covariates
treat = sample(c(0, 1), size = N, replace = T, prob = c(0.5, 0.5)) # not treated (treat = 0)
                                                                   # treated (treat = 1)
age = rnorm(N, 40, 10) # age
ageZ = (rnorm(N, 40, 10) - 40)/10 # rescaling: standardized age
  
# event and censoring coefficients
lx = 0.05; beta = c(0.5, 0.8) # moderate dependency
lc = 0.02; phi = c(1, 1.5) # strong dependency

u1 = runif(N, 0, 1)
u2 = runif(N, 0, 1)
```

# Main function: initialize storing elements, apply methods, compute performance metrics and curves

-   **Input:** "true" generated data (from which we sample at each MC iteration) and "true" underlying curve (with which we compute the performance metrics at each MC iteration)
-   **Output:** list with performance metrics and estimated KM curve, IPCW curve & GC curve

- **Performance Metrics:** Absolute Bias summarizes the average pointwise error between the estimated survival curve and the true curve. This metric can remain low if the DR estimator follows the true curve closely in most places. 
However, the ABC (calculated using the trapezoid rule) measures the accumulated error over the entire time range. If the DR curve deviates significantly from the true curve at specific intervals (even if the deviations are localized), the accumulated error could be high. ABC penalizes large deviations over time.

```{r}
main = function(true_data, true_curve, sample_size = c(200, 500, 1000)){
  
  # list of lists for the output of each sample size
  out = vector("list", 3)
  names(out) = c(paste0("n = ", sample_size[1]), 
                 paste0("n = ", sample_size[2]), 
                 paste0("n = ", sample_size[3]))
  
  for (ni in 1:length(sample_size)){
      n = sample_size[ni]
      print(n)
      # censoring percentage for each MC simulation at each misspecification case
      censoring = numeric(M)
      
      # maximum time of event/censoring
      max_t = numeric(M)
      
      # survival curve estimates at each time point for each MC simulation 
      KM = matrix(NA, nrow = M, ncol = nt)
      IPCW = matrix(NA, nrow = M, ncol = nt)
      GC = matrix(NA, nrow = M, ncol = nt)
      DR_Stab = matrix(NA, nrow = M, ncol = nt)
      DR_WGC = matrix(NA, nrow = M, ncol = nt)
      
      # performance metrics for each MC simulation 
      KM_metrics = matrix(NA, nrow = M, ncol = 3)
      colnames(KM_metrics) = c("Absolute Bias", #"Variance", 
                               "RMSE", "Area Between Curves")
      IPCW_metrics = matrix(NA, nrow = M, ncol = 3)
      colnames(IPCW_metrics) = c("Absolute Bias", #"Variance", 
                                 "RMSE", "Area Between Curves")
      GC_metrics = matrix(NA, nrow = M, ncol = 3)
      colnames(GC_metrics) = c("Absolute Bias", #"Variance", 
                               "RMSE", "Area Between Curves") 
      DR_metrics_Stab = matrix(NA, nrow = M, ncol = 3)
      colnames(DR_metrics_Stab) = c("Absolute Bias", #"Variance",
                               "RMSE", "Area Between Curves")
      DR_metrics_WGC = matrix(NA, nrow = M, ncol = 3)
      colnames(DR_metrics_WGC) = c("Absolute Bias", #"Variance", 
                                "RMSE", "Area Between Curves")
      
      skip = 0
      # MC simulations
      for (i in 1:M){
        print(i)
        
        # Re-sampling from the "real" data set
        sampled_ids = sample(1:nrow(true_data), size = n, replace = T)
        data = true_data[sampled_ids, ]
        
        censoring[i] = sum(data$d == 0)/nrow(data)
        max_t[i] = max(data$Tobs)
        
        ## Kaplan - Meier ##
      
        # Kaplan - Meier curves
        KM_fit = survfit(Surv(Tobs, d) ~ 1, data)
        KM_surv = summary(KM_fit, times = tt, extend = TRUE)$surv
        KM[i, ] = KM_surv
      
        # KM performance metrics
        KM_metrics[i, ] = c(mean(abs(KM_surv - true_curve)), 
                            #var(KM_surv - true_curve),
                            #var(KM_surv),
                            sqrt(mean((KM_surv - true_curve)^2)),
                            geiger:::.area.between.curves(tt, true_curve, KM_surv, 
                                                          xrange = c(0, max(tt))))
    
        ## IPCW ##
    
        # transform data from wide to long format
    
        data_wide = data[, c("id", "Tobs", "d", "treatment", "ageZ")]
        # censoring indicator
        data_wide$dC = 1 - data_wide$d
      
        # start of all intervals
        data_wide$Tstart = 0
      
        # all event and censoring time points
        times = sort(unique(data_wide$Tobs))
      
        # split for event times
        data_long = survSplit(data_wide,
                              cut = times, # boundaries
                              end = "Tobs", # event time
                              start = "Tstart", # start time
                              event = "d") # event indicator
      
        # split for censoring times
        data_long_cens = survSplit(data_wide,
                                   cut = times, # boundaries
                                   end = "Tobs", # event time
                                   start = "Tstart", # start time
                                   event = "dC") # censoring indicator
      
        data_long$dC = data_long_cens$dC
      
        data_long = data_long[, c("id", "treatment", "ageZ",  "d", "dC", "Tstart", "Tobs")]
        colnames(data_long)[colnames(data_long) == "Tobs"] = "Tstop"
        
        # Calculate the IPCW weights
        ipw = NULL
        tryCatch(
          {ipw = ipwtm(exposure = dC,
                       family = "survival",
                       denominator = ~ treatment + ageZ,
                       #denominator = ~ treatment + I(ageZ^2), # for S3
                       id = id,
                       tstart = Tstart,
                       timevar = Tstop,
                       type = "cens",
                       data = data_long)},
          error = function(e) {
            if (grepl("aeqSurv exception, an interval has effective length 0", e$message)) {
              warning("Zero-length interval error detected in ipwtm.")
            }
          }
        )
        
       if (is.null(ipw) | length(ipw$ipw.weights) != nrow(data_long)) {
          # skip this iteration if ipwtm failed
          skip = skip + 1
          next
        } 
        
        data_long$Wi = ipw$ipw.weights
    
        # Estimate the weighted survival curve for time to event
        surv_IPCW = NULL
        tryCatch(
          {surv_IPCW = survfit(Surv(Tstart, Tstop, d) ~ 1, data = data_long, weights = Wi)},
          error = function(e) {
            if (grepl("aeqSurv exception, an interval has effective length 0", e$message)) {
              warning("Zero-length interval error detected in survfit.")
            }
          }
        )     
              
        if (is.null(surv_IPCW)) {
          # skip this iteration if survfit failed
          skip = skip + 1
          next
        }
      
        survIPCW = summary(surv_IPCW, times = tt, extend = TRUE)$surv
        IPCW[i, ] = survIPCW
      
        # IPCW metrics
        IPCW_metrics[i, ] = c(mean(abs(survIPCW - true_curve)),
                              #var(survIPCW),
                              #var(survIPCW - true_curve),
                              sqrt(mean((survIPCW - true_curve)^2)),
                              geiger:::.area.between.curves(tt, true_curve, survIPCW, 
                                                            xrange = c(0, max(tt))))
        
        ## G-Computation ##
      
        # Step 1: Fit Cox model to the whole population for time to event
        cox_model = coxph(Surv(Tobs, d) ~ treatment + ageZ, data = data)
      
        # Step 2: Estimate individual survival probabilities at each event time point 
        # based on the cox model 
        fit_g = survfit(cox_model, newdata = data)
      
        # estimate individual survival probabilities at the time grid
        fit_g_ext = summary(fit_g, times = tt, extend = TRUE)$surv
      
        # Step 3: Mean survival probability at each time point
        surv_g = rowMeans(fit_g_ext)
        
        GC[i, ] = surv_g
      
        # GC metrics 
        GC_metrics[i, ] = c(mean(abs(surv_g - true_curve)),
                            #var(surv_g),
                            #var(surv_g - true_curve),
                            sqrt(mean((surv_g - true_curve)^2)),                     
                            geiger:::.area.between.curves(tt, true_curve, surv_g, 
                                                          xrange = c(0, max(tt))))
        
        ## Weighted GC ## 
        
        cox_model_dr = coxph(Surv(Tstart, Tstop, d) ~ treatment + ageZ, data = data_long, weights = Wi)
        fit_g_dr = survfit(cox_model_dr, newdata = data)
        fit_g_ext_dr = summary(fit_g_dr, times = tt, extend = TRUE)$surv
        surv_g_dr = rowMeans(fit_g_ext_dr)
        
        DR_WGC[i, ] = surv_g_dr
        
        # metrics
        DR_metrics_WGC[i, ] = c(mean(abs(surv_g_dr - true_curve)),
                                #var(surv_g_dr),
                                #var(surv_g_dr - true_curve),
                                sqrt(mean((surv_g_dr - true_curve)^2)),                     
                                geiger:::.area.between.curves(tt, true_curve, surv_g_dr, 
                                                              xrange = c(0, max(tt))))
        
        ## AIPCW ##
        
        DR_df = data.frame(matrix(NA, nrow = nt*n, ncol = 8))
        names(DR_df) = c("id", "time", "d", "dC", "Tobs", "mu", "pi", "pi_stab")
        
        # fit Cox model for time to censoring
        data$dC = 1 - data$d
        cox_cens = coxph(Surv(Tobs, dC) ~ treatment + ageZ, data = data) ##### computing time reduction
        survfit_cens = survfit(cox_cens, newdata = data) ##### computing time reduction
        weight_ext = summary(survfit_cens, times = tt)
        weights_aggreg = weight_ext$surv ### P(uncensored) e (0,1) ## K
        
        cox_cens_marginal = coxph(Surv(Tobs, dC) ~ 1, data = data)
        survfit_cens_marginal = survfit(cox_cens_marginal)
        weights0 = summary(survfit_cens_marginal, times = tt)$surv  
        
        # stabilized IPCW
        stabilized_weights = weights0 / weights_aggreg
        
        # estimate the probability of being uncensored for every subject at each time point
        b = 0
        for(j in 1:nrow(data)){
          idj = data[j, "id"]
          status_d = data[j, "d"]
          Tobserved = data[j, "Tobs"]
          time_round = round(Tobserved, digits = 1)
          
          if (time_round > 200){ # event beyond the time grid we're studying
            DR_df[(b*nt + 1):(b*nt + nt), "d"] = 0
            DR_df[(b*nt + 1):(b*nt + nt), "dC"] = 0
          } else {
            ind = which(abs(tt - as.numeric(time_round)) < 1e-6) ##### computing time reduction
          
            # did the event happen before or after `time`?
            if (Tobserved < time_round){
              a = - 1
            } else {
              a = 0
            }
            
            if (status_d == 0){ #censored
              DR_df[(b*nt + 1):(b*nt + ind + a), "d"] = 0
              DR_df[(b*nt + ind + a + 1):(b*nt + nt), "d"] = 1
              DR_df[(b*nt + 1):(b*nt + ind + a), "dC"] = 0
              DR_df[(b*nt + ind + a + 1):(b*nt + nt), "dC"] = 1
            } else { #dead
              DR_df[(b*nt + 1):(b*nt + nt), "dC"] = 0
              DR_df[(b*nt + 1):(b*nt + ind + a), "d"] = 0
              DR_df[(b*nt + ind + a + 1):(b*nt + nt), "d"] = 1
            }
          }
          
          DR_df[(b*nt + 1):(b*nt + nt), "id"] = idj
          DR_df[(b*nt + 1):(b*nt + nt), "time"] = tt
          DR_df[(b*nt + 1):(b*nt + nt), "Tobs"] = Tobserved
      
          # Z
          DR_df$Z = as.numeric((DR_df$dC == 1) | (DR_df$d == 0))
          
          # Weights model
          col_ind_w = which(as.numeric(colnames(weights_aggreg)) == idj)
          weights = weights_aggreg[, col_ind_w]
          
          col_ind_w = which(as.numeric(colnames(stabilized_weights)) == idj)
          weights_stab = stabilized_weights[, col_ind_w]
         
          if (length((b*nt + 1):(b*nt + nt)) != length(weights)){ 
            # the max event or censoring time was before T = 200
            nl = length(weights)
            DR_df[(b*nt + 1):(b*nt + nl), "pi"] = weights 
            DR_df[(b*nt + 1):(b*nt + nl), "pi_stab"] = weights_stab
            
            # for these time points: there is no one left alive or uncensored  
            # (won't be used in the calculation of the DR estimator anyway)
            DR_df[(b*nt + nl + 1):(b*nt + nt), "pi"] = tail(weights, n = 1) 
            DR_df[(b*nt + nl + 1):(b*nt + nt), "pi_stab"] = tail(weights_stab, n = 1)
          } else {
            DR_df[(b*nt + 1):(b*nt + nt), "pi"] = weights 
            DR_df[(b*nt + 1):(b*nt + nt), "pi_stab"] = weights_stab
          }
          
          ## Regression model
          col_ind = which(as.numeric(colnames(fit_g_ext)) == idj)
          DR_df[(b*nt + 1):(b*nt + nt), 'mu'] = fit_g_ext[, col_ind]
          
          b = b + 1 # number of ids
        }
        
        DR_df[which(DR_df$pi == 0 | is.na(DR_df$pi)), "pi"] = 10e-50
        DR_df[which(DR_df$pi_stab == 0 | is.na(DR_df$pi_stab)), "pi_stab"] = 10e-50
        
        # Compute the DR_Stab curve in a grouped manner
        
        DR_curve_df = DR_df |>
            group_by(time) |> ##### computing time reduction
            summarize(DRcurve = mean((((dC == 0) & (d == 0) * Z) / pi_stab) - (((dC == 0) / pi_stab) - 1) * mu * Z))
    
        DR_stab_curve = DR_curve_df$DRcurve
    
        DR_Stab[i, ] = DR_stab_curve
        
        # DR performance metrics
        DR_metrics_Stab[i, ] = c(mean(abs(DR_stab_curve - true_curve)),
                                 #var(DR_stab_curve),
                                 #var(DR_stab_curve - true_curve),
                                 sqrt(mean((DR_stab_curve - true_curve)^2)),
                                 geiger:::.area.between.curves(tt, true_curve, DR_stab_curve,
                                                               xrange = c(0, max(tt))))
      }
      
      # Mean results over M simulations
      
      censoring_perc = mean(censoring, na.rm = TRUE)
      
      KM_curve = colMeans(KM, na.rm = TRUE)
      KM_Metrics = colMeans(KM_metrics, na.rm = TRUE)
      KM_Metrics_final = c(KM_Metrics, 'Variance' = mean(colVars(KM, na.rm = TRUE), na.rm = TRUE))
      
      IPCW_curve = colMeans(IPCW, na.rm = TRUE)
      IPCW_Metrics = colMeans(IPCW_metrics, na.rm = TRUE)
      IPCW_Metrics_final = c(IPCW_Metrics, 'Variance' = mean(colVars(IPCW, na.rm = TRUE), na.rm = TRUE))
      
      GC_curve = colMeans(GC, na.rm = TRUE)
      GC_Metrics = colMeans(GC_metrics, na.rm = TRUE)
      GC_Metrics_final = c(GC_Metrics, 'Variance' = mean(colVars(GC, na.rm = TRUE), na.rm = TRUE))
      
      DR_curve_Stab = colMeans(DR_Stab, na.rm = TRUE)
      DR_Metrics_Stab = colMeans(DR_metrics_Stab, na.rm = TRUE)
      DR_Metrics_Stab_final = c(DR_Metrics_Stab, 'Variance' = mean(colVars(DR_Stab, na.rm = TRUE), na.rm = TRUE))
     
      DR_curve_WGC = colMeans(DR_WGC, na.rm = TRUE)
      DR_Metrics_WGC = colMeans(DR_metrics_WGC, na.rm = TRUE)
      DR_Metrics_WGC_final = c(DR_Metrics_WGC, 'Variance' = mean(colVars(DR_WGC, na.rm = TRUE), na.rm = TRUE))
      
      # merge performance metrics
      final_metrics = cbind(KM_Metrics_final, IPCW_Metrics_final, GC_Metrics_final, 
                            DR_Metrics_Stab_final, DR_Metrics_WGC_final)
      final_metrics = as.data.frame(final_metrics)
      colnames(final_metrics) = c("KM", "IPCW", "G-C", "DR_StabW", "DR_WGC")
      
      # output
      out_n = list('censoring_percentage' = censoring_perc,
                   'skips' = skip,
                   'maxt' = mean(max_t),
                   'performance_metrics' = final_metrics,
                   'KM_curve' = KM_curve,
                   'IPCW_curve' = IPCW_curve,
                   'GC_curve' = GC_curve,
                   'DR_StabW' = DR_curve_Stab,
                   'DR_WGC' = DR_curve_WGC)
      
      out[[ni]] = out_n
  }
 return(out)
}
```

# Scenario 1: Correctly Specified Models

```{r}
## Generate Data ##
  
x = (-log(u1))/(lx * exp(beta[1]*treat + beta[2]*ageZ))
c = (-log(u2))/(lc * exp(phi[1]*treat + phi[2]*ageZ))

t = pmin(x, c) # observed time
d = as.numeric(x <= c) # event indicator 

true_data = data.frame(id = 1:N, X = x, C = c, Tobs = t, d = d, 
                       treatment = treat, age = age, ageZ = ageZ)
  
## True curve ##
  
integrand = function(t, z1, z2){
  exp(-lx * t * exp(beta[1]*z1 + beta[2]*z2)) * dnorm(z2)
}

true_surv_integr = numeric(nt)
for (i in 1:nt){
  true_surv_integr[i] = 0.5*(integrate(integrand, t = tt[i], z1 = 1, lower = -5, upper = 5)$value + 
                               integrate(integrand, t = tt[i], z1 = 0, lower = -5, upper = 5)$value)
}

tc1 = Sys.time()
out_s1 = main(true_data, true_surv_integr)
tc2 = Sys.time()
tc2 - tc1
```

```{r}
save(out_s1, file = "results_final/M200_v3/results_s1.RData")
```

## Plots and results

```{r}
paste0("Censoring percentage in Scenario 1: ", 
       round(out_s1$censoring_percentage*100, digits = 2), "%")
paste0("Number of skipped MC simulations in Scenario 1: ", out_s1$skips)
paste0("Maximum Tobs in Scenario 1: ", round(out_s1$maxt, digits = 2))
```


```{r fig.width = 10, fig.height = 10}
plot(tt, true_surv_integr, type = "s", lwd = 2, bty = "l", las = 1,
     xlab = "Time", ylab = "Survival Probability",
     main = "Scenario 1: Correctly Specified Models")
lines(tt, out_s1$KM_curve, type = "s", col = "red", lwd = 2, lty = 2)
lines(tt, out_s1$IPCW_curve, type = "s", col = "darkgreen", lwd = 2, lty = 4)
lines(tt, out_s1$GC_curve, type = "s", col = "blue", lwd = 2, lty = 3)
lines(tt, out_s1$DR_StabW, type = "s", col = "purple", lwd = 2, lty = 6)
lines(tt, out_s1$DR_WGC, type = "s", col = "orange", lwd = 2, lty = 2)

legend("topright", title = "Survival Curves", bty = "n", 
       c("True theoretical", "Kaplan-Meier", 
         "IPCW", "G-Computation", 
         "DR - StabW", "DR - WGC"),
       col = c("black", "red", "darkgreen", "blue", "purple", "orange"), 
       lwd = 2, lty = c(1, 2, 4, 3, 6, 2))
```

```{r}
out_s1$performance_metrics
```

# Scenario 2: Misspecify Censoring Model

-   Older individuals (ageZ > 0) have a higher hazard of getting censored and smaller censoring times. exp(5) = 148.4

```{r}
## Generate Data ##
  
x = (-log(u1))/(0.03 * exp(beta[1]*treat + beta[2]*ageZ))
c = (-log(u2))/(0.01 * exp(phi[1]*treat + 5*(ageZ > 0)))

t = pmin(x, c) # observed time
d = as.numeric(x <= c) # event indicator 

true_data = data.frame(id = 1:N, X = x, C = c, Tobs = t, d = d, 
                       treatment = treat, age = age, ageZ = ageZ)
  
## True curve ##
  
integrand = function(t, z1, z2){
  exp(-0.03 * t * exp(beta[1]*z1 + beta[2]*z2)) * dnorm(z2)
}

true_surv_integr = numeric(nt)
for (i in 1:nt){
  true_surv_integr[i] = 0.5*(integrate(integrand, t = tt[i], z1 = 1, lower = -5, upper = 5)$value + 
                               integrate(integrand, t = tt[i], z1 = 0, lower = -5, upper = 5)$value)
}

tc1 = Sys.time()
out_s2b = main(true_data, true_surv_integr)
tc2 = Sys.time()
tc2 - tc1
```

```{r}
save(out_s2b, file = "results_final/M200_v3/results_s2b.RData")
```

## Plots and results

```{r}
paste0("Censoring percentage in Scenario 2: ", 
       round(out_s2$censoring_percentage*100, digits = 2), "%")
paste0("Number of skipped MC simulations in Scenario 2: ", out_s2$skips)
paste0("Maximum Tobs in Scenario 2: ", round(out_s2$maxt, digits = 2))
```

```{r fig.width = 10, fig.height = 10}
plot(tt, true_surv_integr, type = "s", lwd = 2, bty = "l", las = 1,
     xlab = "Time", ylab = "Survival Probability",
     main = "Scenario 2: Misspecify Censoring Model")
lines(tt, out_s2$KM_curve, type = "s", col = "red", lwd = 2, lty = 2)
lines(tt, out_s2$IPCW_curve, type = "s", col = "darkgreen", lwd = 2, lty = 4)
lines(tt, out_s2$GC_curve, type = "s", col = "blue", lwd = 2, lty = 3)
lines(tt, out_s2$DR_StabW, type = "s", col = "purple", lwd = 2, lty = 6)
lines(tt, out_s2$DR_WGC, type = "s", col = "orange", lwd = 2, lty = 2)

legend("topright", title = "Survival Curves", bty = "n", 
       c("True theoretical", "Kaplan-Meier", 
         "IPCW", "G-Computation", 
         "DR - StabW", "DR - WGC"),
       col = c("black", "red", "darkgreen", "blue", "purple", "orange"), 
       lwd = 2, lty = c(1, 2, 4, 3, 6, 2))
```

```{r}
out_s2$performance_metrics
```

# Scenario 3: Misspecify Outcome Model

- quadratic term of age in X
- quadratic term of age in C and **in the modelling of C**

```{r}
## Generate Data ##
  
x = (-log(u1))/(0.01 * exp(beta[1]*treat + 1*I(ageZ^2)))
c = (-log(u2))/(0.01 * exp(phi[1]*treat + 1*I(ageZ^2))) # add quadratic term of age also to censoring model

t = pmin(x, c) # observed time
d = as.numeric(x <= c) # event indicator 

true_data = data.frame(id = 1:N, X = x, C = c, Tobs = t, d = d, 
                       treatment = treat, age = age, ageZ = ageZ)
  
## True curve ##
  
integrand = function(t, z1, z2){
  exp(-0.01 * t * exp(beta[1]*z1 + 1*I(z2^2))) * dnorm(z2)
}

true_surv_integr = numeric(nt)
for (i in 1:nt){
  true_surv_integr[i] = 0.5*(integrate(integrand, t = tt[i], z1 = 1, lower = -5, upper = 5)$value + 
                               integrate(integrand, t = tt[i], z1 = 0, lower = -5, upper = 5)$value)
}

tc1 = Sys.time()
out_s3 = main(true_data, true_surv_integr)
tc2 = Sys.time()
tc2 - tc1
```

```{r}
save(out_s3, file = "results_final/M200_v3/results_s3.RData")
```

## Plots and results

```{r}
paste0("Censoring percentage in Scenario 3: ", 
       round(out_s3$censoring_percentage*100, digits = 2), "%")
paste0("Number of skipped MC simulations in Scenario 3: ", out_s3$skips)
paste0("Maximum Tobs in Scenario 3: ", round(out_s3$maxt, digits = 2))
```

The IPCW fails to capture the true survival curve in the beginning, even though the censoring model is correctly specified. It could be attributed to **sampling variability**. We expect to get rid of that by running a bigger number of simulations. 

```{r fig.width = 10, fig.height = 10}
plot(tt, true_surv_integr, type = "s", lwd = 2, bty = "l", las = 1,
     xlab = "Time", ylab = "Survival Probability",
     main = "Scenario 3: Misspecify Outcome Model")
lines(tt, out_s3$KM_curve, type = "s", col = "red", lwd = 2, lty = 2)
lines(tt, out_s3$IPCW_curve, type = "s", col = "darkgreen", lwd = 2, lty = 4)
lines(tt, out_s3$GC_curve, type = "s", col = "blue", lwd = 2, lty = 3)
lines(tt, out_s3$DR_StabW, type = "s", col = "purple", lwd = 2, lty = 6)
lines(tt, out_s3$DR_WGC, type = "s", col = "orange", lwd = 2, lty = 2)

legend("topright", title = "Survival Curves", bty = "n", 
       c("True theoretical", "Kaplan-Meier", 
         "IPCW", "G-Computation", 
         "DR - StabW", "DR - WGC"),
       col = c("black", "red", "darkgreen", "blue", "purple", "orange"), 
       lwd = 2, lty = c(1, 2, 4, 3, 6, 2))
```

```{r}
out_s3$performance_metrics
```

# Scenario 4: Misspecify Both Models

-   X event time: add quadratic term of age
-   C censoring time: add quadratic term of age

```{r}
## Generate Data ##

x = (-log(u1))/(0.01 * exp(beta[1]*treat + 1*(I(ageZ^2))))
c = (-log(u2))/(0.01 * exp(phi[1]*treat + 1*(I(ageZ^2))))

t = pmin(x, c) # observed time
d = as.numeric(x <= c) # event indicator 

true_data = data.frame(id = 1:N, X = x, C = c, Tobs = t, d = d, 
                       treatment = treat, age = age, ageZ = ageZ)
  
## True curve ##
  
integrand = function(t, z1, z2){
  exp(-0.01 * t * exp(beta[1]*z1 + 1*I(z2^2))) * dnorm(z2)
}

true_surv_integr = numeric(nt)
for (i in 1:nt){
  true_surv_integr[i] = 0.5*(integrate(integrand, t = tt[i], z1 = 1, lower = -5, upper = 5)$value + 
                               integrate(integrand, t = tt[i], z1 = 0, lower = -5, upper = 5)$value)
}

tc1 = Sys.time()
out_s4 = main(true_data, true_surv_integr)
tc2 = Sys.time()
tc2 - tc1
```

```{r}
save(out_s4, file = "results_final/M200_v3/results_s4.RData")
```

## Plots and results

```{r}
paste0("Censoring percentage in Scenario 4: ", 
       round(out_s4$censoring_percentage*100, digits = 2), "%")
paste0("Number of skipped MC simulations in Scenario 4: ", out_s4$skips)
paste0("Maximum Tobs in Scenario 4: ", round(out_s4$maxt, digits = 2))
```

When both models are misspecified, DR_Stab performs better than the individual methods!

```{r fig.width = 10, fig.height = 10}
plot(tt, true_surv_integr, type = "s", lwd = 2, bty = "l", las = 1,
     xlab = "Time", ylab = "Survival Probability",
     main = "Scenario 4: Misspecify Both Models")
lines(tt, out_s4$KM_curve, type = "s", col = "red", lwd = 2, lty = 2)
lines(tt, out_s4$IPCW_curve, type = "s", col = "darkgreen", lwd = 2, lty = 4)
lines(tt, out_s4$GC_curve, type = "s", col = "blue", lwd = 2, lty = 3)
lines(tt, out_s4$DR_StabW, type = "s", col = "purple", lwd = 2, lty = 6)
lines(tt, out_s4$DR_WGC, type = "s", col = "orange", lwd = 2, lty = 2)

legend("topright", title = "Survival Curves", bty = "n", 
       c("True theoretical", "Kaplan-Meier", 
         "IPCW", "G-Computation", 
         "DR - StabW", "DR - WGC"),
       col = c("black", "red", "darkgreen", "blue", "purple", "orange"), 
       lwd = 2, lty = c(1, 2, 4, 3, 6, 2))
```

```{r}
out_s4$performance_metrics
```

# Scenario 4b: Misspecify Both Models

```{r}
## Generate Data ##

x = (-log(u1))/(0.01 * exp(beta[1]*treat + 2*(ageZ > 0)))
c = (-log(u2))/(0.01 * exp(phi[1]*treat + 5*(ageZ > 0)))

t = pmin(x, c) # observed time
d = as.numeric(x <= c) # event indicator 

true_data = data.frame(id = 1:N, X = x, C = c, Tobs = t, d = d, 
                       treatment = treat, age = age, ageZ = ageZ)

## True curve ##

integrand = function(t, z1, z2){
  exp(-0.01 * t * exp(beta[1]*z1 + 2*(z2 > 0))) * dnorm(z2)
}

true_surv_integr = numeric(nt)
for (i in 1:nt){
    true_surv_integr[i] = 0.5*(integrate(integrand, t = tt[i], z1 = 1, lower = -5, upper = 5)$value + 
                                   integrate(integrand, t = tt[i], z1 = 0, lower = -5, upper = 5)$value)
}

tc1 = Sys.time()
out_s4b = main(true_data, true_surv_integr)
tc2 = Sys.time()
tc2 - tc1
```

```{r}
save(out_s4b, file = "results_final/M200_v3/results_s4b.RData")
```

## Plots and results

```{r}
paste0("Censoring percentage in Scenario 4b: ", 
       round(out_s4b$censoring_percentage*100, digits = 2), "%")
paste0("Number of skipped MC simulations in Scenario 4b: ", out_s4b$skips)
paste0("Maximum Tobs in Scenario 4b: ", round(out_s4b$maxt, digits = 2))
```
    
```{r fig.width = 10, fig.height = 10}
plot(tt, true_surv_integr, type = "s", lwd = 2, bty = "l", las = 1,
     xlab = "Time", ylab = "Survival Probability",
     main = "Scenario 4b: Misspecify Both Models")
lines(tt, out_s4b$KM_curve, type = "s", col = "red", lwd = 2, lty = 2)
lines(tt, out_s4b$IPCW_curve, type = "s", col = "darkgreen", lwd = 2, lty = 4)
lines(tt, out_s4b$GC_curve, type = "s", col = "blue", lwd = 2, lty = 3)
lines(tt, out_s4b$DR_StabW, type = "s", col = "purple", lwd = 2, lty = 6)
lines(tt, out_s4b$DR_WGC, type = "s", col = "orange", lwd = 2, lty = 2)

legend("topright", title = "Survival Curves", bty = "n", 
       c("True theoretical", "Kaplan-Meier", 
         "IPCW", "G-Computation", 
         "DR - StabW", "DR - WGC"),
       col = c("black", "red", "darkgreen", "blue", "purple", "orange"), 
       lwd = 2, lty = c(1, 2, 4, 3, 6, 2))
```

```{r}
out_s4b$performance_metrics
```